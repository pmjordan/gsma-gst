tosca_definitions_version: tosca_simple_yaml_1_3
description: A TOSCA template to deploy the app for wheresmychargepoint.com on a MEC identified by its IP address supplied as an input and direct requests to it

metadata:
  # The following fields are "normative" and expected in TOSCA 
  template_name: generic_app
  template_author: paul.m.jordan@bt.com
  template_version: '1.0'
  # look for syntax error with the command below
  parse_command: puccini-tosca --quirk data_types.timestamp.permissive parse "tosca/mec_hosting_enablementwheresmychargepoint.com.yml" -i targetComputeAdminAddress="10.10.10.10" -i public_app_address="1.1.1.1"> out.yml
  # the quirk in the above command tells puccini to allow timestamps in yaml format as used by sid.yml

imports:
  # would normally refer to external repository but for now make it local
  - file: tosca/sid.yml
  # The content is a TOSCA encoding of selected SID information model entities as explained in IG1176 plus some small updates
    namespace_prefix: sid

repositories:

  deployment_repo:
    url: http://cloudrepo.com:8080 # This will have been populated from a jinja2 field
    credential:
      user: username
      token: token123
      keys:
        cert: cloudrepo.pem

data_types:
  app_url_type:
    derived_from: string
    description: The url used to reach an app when deployed on a MEC

capability_types:
  MECManager:
    derived_from: tosca.capabilities.Node
    valid_source_types: [ smf_type ]

  monitor_performance:
    derived_from: tosca.capabilities.Node
    valid_source_types: [ performance_monitor_type ]


interface_types:
  smf_management:
    derived_from: tosca.interfaces.Root
    operations:
      redirect:
        inputs:
          app_url:
            type: app_url_type
          public_app_address:
            type: string

  performance_monitor_config:
    derived_from: tosca.interfaces.Root
    operations:
      specify_app:
        inputs:
          app_url:
            type: app_url_type
          SLO:
            type: sid:MetricDefinition


node_types:
  hosted_app_type:
    derived_from: tosca.nodes.SoftwareComponent
    requirements:
      - host:
          occurrences: [ 1, UNBOUNDED ]
    interfaces:
      Standard:
        operations:
          create:
            inputs:
              deployment_file:
                type: string
          configure:
            inputs: 
              sync_data:
                type: string

  mec_type:
    derived_from: tosca.nodes.Compute
    requirements:
      - controlling_smf:
          capability: MECManager
          node: smf_type
          relationship: DependsOn

  smf_type:
    derived_from: tosca.nodes.Root
    capabilities:
      manage_mecs:
        type: MECManager
        occurrences: [ 0, UNBOUNDED ]
    interfaces:
      smf_management:
        type: smf_management

  performance_monitor_type:
    derived_from: tosca.nodes.Root
    capabilities:
      monitor_app:
        type: monitor_performance
        occurrences: [ 0, 1 ]
    interfaces:
      performance_monitor_config:
        type: 
          performance_monitor_config

topology_template:
  inputs:
    targetComputeAdminAddress:
      type: string
    public_app_address:
      type: string

  node_templates:
    myApp:
      # as this is a classic VNF we have a choice of how to model it. Could be based on TOSCA node types, SID software entities or ETSI VNFs. Depends on what is easiest for the orchestrator vendor. 
      # We have therefore chosen TOSCA native but the downside is that the create artefact URL and the URL of the repository on which it is store both need to be passed in as inputs but TOSCA does not allow these to be paramterized.
      # The work around is to move these parts to an external file so that only one line in this generic template needs to be edited.
      type: hosted_app_type #tosca.nodes.SoftwareComponent
      interfaces:
        Standard:
          operations:
            create:
              implementation: http://csp.com/hosted_app/scripts/create.sh # create.sh code says get the create artifact and process that
              inputs: 
                deployment_file: { get_artifact: [ SELF, mydeployment_file ] }
            configure:
              implementation: scripts/configure.sh
              inputs: 
                sync_data: { get_artifact: [ SELF, data ] }
      requirements:
        # SoftwareComponent requires hosting on Compute by definition but supplement that requirement for an abstract node
        - host: 
            node: myapp_compute

      artifacts:
        mydeployment_file: 
          description: The actual install file for this app
          repository: deployment_repo
          file: /files/WheresMyChargePoint_w1-wip1.csar # This will have been populated from a jinja2 field

        data: data_url.com # This will have been populated from a jinja2 field

    # Abstract node template (placeholder) to be selected by provider        
    myapp_compute:
      type : mec_type
      directives: [ select ]
      # This node_filter ensures that the mecs picked by the orchestrator for hosting the app are ones in the list of required addresses used to ID the MECs
      node_filter:
        capabilities:
          - host:
              properties:
                private_address: 
                  - in_range: {get_input: [ targetComputeAdminAddress ] }

    mecs_controlling_smf:
      type: smf_type
      directives: [ select ]
      interfaces:
        smf_management:
          operations:
            redirect:
              inputs:
                app_url: wheresmychargepoint.com # This will have been populated from a jinja2 field
                # assume new address is public address of the mec but may have to be an input if a load balancer is used thus
                    # new_address: { get_attribute: [ myapp_compute, public_address ] }
                    # else just get it as an input
                public_app_address: { get_input: public_app_address }

    performance_monitor:
      type: performance_monitor_type
      directives: [ select ]
      interfaces:
        performance_monitor_config:
          operations:
            specify_app:
              inputs:
                app_url: test.com
                SLO:
                  ## This value is currently hardcoded but should really be derived from the SLO value supplied with the order using the same technique as app_public_url
                  _metricDefMeasure:
                    measure1:
                      unitOfMeasure:
                        # so we measure in 1/100 000 ths
                        amount: 0.00001
                        # availability is a ratio and so has no units. User interface may choose to display it as a percentage
                        units: None
                      valueType: float
                      _metricDefinitionThresholdSet:
                        threshold_set1:
                          thresholdType: LogicDefinition
                          _metricDefMeasureThresholdRule:
                          # the above which comes from the node definition points to a superclass but for this instance we want to use a child of that superclass ie MetricThresholdRuleDefinition the child of MetricDefMeasureThresholdRule
                            rule1:
                              conformanceTargetLower: 0.9999
                              conformanceComparatorLower: LE


  workflows:
    deploy:
      inputs:
        app_url: 
          type: string
      steps:
        install:
          target: myApp
          activities:
            - set_state: creating
            - call_operation: Standard.create
            - set_state: created
          on_success:
            - sync
        sync:
          target: myApp
          activities:
            - set_state: configuring
            - call_operation: Standard.configure
            - set_state: configured
          on_success:
            - redirect
        redirect:
          target: mecs_controlling_smf
          activities:
            - set_state: starting
            - call_operation: smf_management.redirect
            - set_state: started
        monitor:
          target: performance_monitor
          activities:
            - call_operation: performance_monitor_config.specify_app